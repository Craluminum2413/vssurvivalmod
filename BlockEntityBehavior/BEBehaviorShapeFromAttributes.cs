using System.Collections.Generic;
using System.Text;
using Vintagestory.API.Client;
using Vintagestory.API.Common;
using Vintagestory.API.Datastructures;
using Vintagestory.API.MathTools;

namespace Vintagestory.GameContent
{

    public class BEBehaviorShapeFromAttributes : BlockEntityBehavior, IRotatable
    {
        public string Type;
        protected BlockShapeFromAttributes clutterBlock;
        protected MeshData mesh;
        public float rotateX;
        public float rotateZ;
        public bool Collected;

        public string overrideTextureCode;

        public BEBehaviorShapeFromAttributes(BlockEntity blockentity) : base(blockentity)
        {
        }

        public float rotateY { get; internal set; }


        public override void Initialize(ICoreAPI api, JsonObject properties)
        {
            base.Initialize(api, properties);

            clutterBlock = Block as BlockShapeFromAttributes;

            if (Type != null)
            {
                initShape();
            }
        }

        public virtual void initShape()
        {
            if (Type == null || Api == null || Api.Side == EnumAppSide.Server) return;

            

            var cprops = clutterBlock?.GetTypeProps(Type, null, this);
            
            if (cprops != null)
            {
                if (cprops.Randomize)
                {
                    mesh = clutterBlock.GetOrCreateMesh(cprops, null, overrideTextureCode).Clone().Rotate(new Vec3f(0.5f, 0.5f, 0.5f), rotateX, rotateY + cprops.Rotation.Y * GameMath.DEG2RAD, rotateZ).Scale(Vec3f.Zero, 1, 0.98f + GameMath.MurmurHash3Mod(Pos.X, Pos.Y, Pos.Z, 1000) / 1000f * 0.04f, 1);
                } else
                {
                    mesh = clutterBlock.GetOrCreateMesh(cprops, null, overrideTextureCode).Clone().Rotate(new Vec3f(0.5f, 0.5f, 0.5f), rotateX, rotateY + cprops.Rotation.Y * GameMath.DEG2RAD, rotateZ);
                }
                
            }
        }

        public override void OnBlockPlaced(ItemStack byItemStack = null)
        {
            base.OnBlockPlaced(byItemStack);

            if (byItemStack != null) // When generated by worldgen then byItemStack is null
            {
                Type = byItemStack.Attributes.GetString("type");
                Collected = byItemStack.Attributes.GetBool("collected");
            }

            initShape();
        }

        public override void OnBlockRemoved()
        {
            base.OnBlockRemoved();

            var cprops = clutterBlock?.GetTypeProps(Type, null, this);
            if (cprops?.LightHsv != null)
            {
                Api.World.BlockAccessor.RemoveBlockLight(cprops.LightHsv, Pos);
            }
        }

        public override void FromTreeAttributes(ITreeAttribute tree, IWorldAccessor worldAccessForResolve)
        {
            string prevType = Type;
            string prevOverrideTextureCode = overrideTextureCode;
            float prevRotateX = rotateX;
            float prevRotateY = rotateY;
            float prevRotateZ = rotateZ;

            Type = tree.GetString("type");
            if (Type != null) {
                Type = BlockClutter.Remap(worldAccessForResolve, Type);
            }

            rotateX = tree.GetFloat("rotateX");
            rotateY = tree.GetFloat("meshAngle");
            rotateZ = tree.GetFloat("rotateZ");
            overrideTextureCode = tree.GetString("overrideTextureCode");
            Collected = tree.GetBool("collected");

            if ((mesh == null || prevType != Type || prevOverrideTextureCode != overrideTextureCode || rotateX != prevRotateX || rotateY != prevRotateY || rotateZ != prevRotateZ) && Api != null && worldAccessForResolve.Side == EnumAppSide.Client)
            {
                initShape();
                relight(prevType);
                Blockentity.MarkDirty(true);
            }
        }

        protected void relight(string oldType)
        {
            var cprops = clutterBlock?.GetTypeProps(oldType, null, this);
            if (cprops?.LightHsv != null)
            {
                Api.World.BlockAccessor.RemoveBlockLight(cprops.LightHsv, Pos);
            }

            cprops = clutterBlock?.GetTypeProps(Type, null, this);
            if (cprops?.LightHsv != null)
            {
                // This should force a relight at this position
                Api.World.BlockAccessor.ExchangeBlock(Block.Id, Pos);
            }
        }

        public override void ToTreeAttributes(ITreeAttribute tree)
        {
            tree.SetString("type", Type);
            tree.SetFloat("rotateX", rotateX);
            tree.SetFloat("meshAngle", rotateY);
            tree.SetFloat("rotateZ", rotateZ);
            tree.SetBool("collected", Collected);

            if (overrideTextureCode!=null) tree.SetString("overrideTextureCode", overrideTextureCode);
            base.ToTreeAttributes(tree);
        }

        public override bool OnTesselation(ITerrainMeshPool mesher, ITesselatorAPI tessThreadTesselator)
        {
            mesher.AddMeshData(mesh);
            return true;
        }

        public void OnTransformed(IWorldAccessor worldAccessor, ITreeAttribute tree, int degreeRotation, Dictionary<int, AssetLocation> oldBlockIdMapping, Dictionary<int, AssetLocation> oldItemIdMapping, EnumAxis? flipAxis)
        {
            float thetaX = tree.GetFloat("rotateX");
            float thetaY = tree.GetFloat("meshAngle");
            float thetaZ = tree.GetFloat("rotateZ");
            var cprops = clutterBlock?.GetTypeProps(Type, null, this);
            if (cprops != null) thetaY += cprops.Rotation.Y * GameMath.DEG2RAD;
            
            float[] m = Mat4f.Create();
            Mat4f.RotateY(m, m, -degreeRotation * GameMath.DEG2RAD);   // apply the new rotation
            Mat4f.RotateX(m, m, thetaX);
            Mat4f.RotateY(m, m, thetaY);
            Mat4f.RotateZ(m, m, thetaZ);

            Mat4f.ExtractEulerAngles(m, ref thetaX, ref thetaY, ref thetaZ);  // extract the new angles
            if (cprops != null) thetaY -= cprops.Rotation.Y * GameMath.DEG2RAD;
            tree.SetFloat("rotateX", thetaX);
            tree.SetFloat("meshAngle", thetaY);
            tree.SetFloat("rotateZ", thetaZ);
            rotateX = thetaX;
            rotateY = thetaY;
            rotateZ = thetaZ;
        }

        public void Rotate(EntityAgent byEntity, BlockSelection blockSel, int dir)
        {
            if (byEntity.Controls.Sneak)
            {
                if (blockSel.Face.Axis == EnumAxis.X)
                {
                    rotateX += GameMath.PIHALF * dir;
                }
                if (blockSel.Face.Axis == EnumAxis.Y)
                {
                    rotateY += GameMath.PIHALF * dir;
                }
                if (blockSel.Face.Axis == EnumAxis.Z)
                {
                    rotateZ += GameMath.PIHALF * dir;
                }
            }
            else
            {
                float deg22dot5rad = GameMath.PIHALF / 4;
                rotateY += deg22dot5rad * dir;
            }

            initShape();
            Blockentity.MarkDirty(true);
        }

        public override void GetBlockInfo(IPlayer forPlayer, StringBuilder dsc)
        {
            base.GetBlockInfo(forPlayer, dsc);

            if (Api is ICoreClientAPI capi)
            {
                if (capi.Settings.Bool["extendedDebugInfo"] == true)
                {
                    dsc.AppendLine("<font color=\"#bbbbbb\">Type:" + Type + "</font>");
                }
            }
        }
    }
}
